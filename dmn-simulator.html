<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>DMN Simulator - Single HTML</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #0f172a;
      color: #e5e7eb;
      margin: 0;
      padding: 0;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 1.5rem;
    }
    .card {
      background: #111827;
      border-radius: 0.75rem;
      padding: 1.5rem;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
      border: 1px solid #1f2937;
    }
    h1 {
      font-size: 1.6rem;
      margin-bottom: 0.5rem;
    }
    h2 {
      font-size: 1.2rem;
      margin-top: 1.5rem;
      margin-bottom: 0.5rem;
    }
    label {
      display: block;
      font-size: 0.85rem;
      margin-bottom: 0.25rem;
      color: #9ca3af;
    }
    input[type="file"],
    select,
    input[type="text"],
    input[type="number"] {
      width: 100%;
      font-size: 0.9rem;
      padding: 0.5rem 0.6rem;
      border-radius: 0.5rem;
      border: 1px solid #374151;
      background: #020617;
      color: #e5e7eb;
      box-sizing: border-box;
    }
    textarea {
      width: 100%;
      min-height: 80px;
      resize: vertical;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.8rem;
      padding: 0.5rem 0.6rem;
      border-radius: 0.5rem;
      border: 1px solid #374151;
      background: #020617;
      color: #e5e7eb;
      box-sizing: border-box;
    }
    button {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      padding: 0.5rem 0.9rem;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      font-size: 0.9rem;
      background: #2563eb;
      color: white;
      margin-right: 0.5rem;
      margin-top: 0.5rem;
    }
    button.secondary {
      background: #4b5563;
    }
    button:disabled {
      opacity: 0.5;
      cursor: default;
    }
    .row-2col {
      display: grid;
      grid-template-columns: 1.1fr 1.4fr;
      gap: 1.5rem;
      align-items: flex-start;
    }
    .mt-1 { margin-top: 0.25rem; }
    .mt-2 { margin-top: 0.5rem; }
    .mt-3 { margin-top: 1rem; }

    pre {
      background: #020617;
      padding: 0.75rem;
      border-radius: 0.5rem;
      font-size: 0.8rem;
      overflow-x: auto;
      border: 1px solid #1f2937;
    }
    .badge {
      display: inline-flex;
      align-items: center;
      padding: 0.1rem 0.5rem;
      border-radius: 999px;
      font-size: 0.7rem;
      background: #1f2937;
      color: #9ca3af;
      margin-left: 0.35rem;
    }
    .error {
      color: #fca5a5;
      font-size: 0.85rem;
      margin-top: 0.25rem;
    }
    .input-field {
      margin-bottom: 0.75rem;
    }
    .input-label-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .input-label-row span.type {
      font-size: 0.7rem;
      color: #9ca3af;
      background: #1f2937;
      border-radius: 999px;
      padding: 0.05rem 0.5rem;
      margin-left: 0.4rem;
    }
    .input-hint {
      font-size: 0.75rem;
      color: #6b7280;
      margin-top: 0.15rem;
    }

    /* Decision table styles */
    #decisionTableWrapper {
      border-radius: 0.75rem;
      border: 1px solid #1f2937;
      overflow: hidden;
      background: #020617;
    }
    table.decision-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.8rem;
    }
    table.decision-table th,
    table.decision-table td {
      padding: 0.35rem 0.45rem;
      border-bottom: 1px solid #1f2937;
      border-right: 1px solid #1f2937;
      text-align: left;
      vertical-align: top;
      max-width: 260px;
      word-wrap: break-word;
    }
    table.decision-table th:last-child,
    table.decision-table td:last-child {
      border-right: none;
    }
    table.decision-table tr:last-child td {
      border-bottom: none;
    }
    table.decision-table thead {
      background: #030712;
    }
    table.decision-table th {
      font-weight: 600;
      color: #e5e7eb;
    }
    table.decision-table th small {
      display: block;
      font-weight: 400;
      color: #9ca3af;
    }
    tr.rule-hit {
      background: linear-gradient(90deg, rgba(22,163,74,0.18), rgba(22,163,74,0.05));
    }
    tr.rule-hit td:first-child {
      border-left: 3px solid #22c55e;
    }
    tr.rule-hit td {
      box-shadow: inset 0 0 0 1px rgba(34,197,94,0.15);
    }
    .rule-index-cell {
      font-weight: 600;
      color: #9ca3af;
      text-align: center;
      white-space: nowrap;
    }
    .rule-legend {
      font-size: 0.75rem;
      color: #6b7280;
      margin-top: 0.35rem;
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }
    .rule-legend span.demo {
      display: inline-block;
      width: 18px;
      height: 10px;
      border-radius: 999px;
      background: linear-gradient(90deg, rgba(22,163,74,0.8), rgba(22,163,74,0.2));
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="card">
      <h1>DMN Simulator (Standalone HTML)</h1>
      <p style="font-size:0.9rem;color:#9ca3af;margin-top:0;">
        Upload a <code>.dmn</code> file, select a decision, fill inputs, and evaluate.
        Everything runs locally in your browser.
      </p>

      <h2>1. Upload DMN</h2>
      <label for="dmnFile">DMN file (.dmn)</label>
      <input id="dmnFile" type="file" accept=".dmn,application/xml,text/xml" />
      <button id="btnParse">Upload &amp; Parse</button>
      <span id="parseStatus" class="badge"></span>
      <div id="parseError" class="error"></div>

      <h2>2. Select decision</h2>
      <label for="decisionSelect">Available decisions</label>
      <select id="decisionSelect">
        <option value="">-- no DMN loaded --</option>
      </select>

      <div class="row-2col mt-3">
        <div>
          <h2>3. Input variables</h2>
          <div id="inputsContainer">
            <p style="font-size:0.85rem;color:#6b7280;">
              Inputs will appear here after selecting a decision.
            </p>
          </div>

          <details class="mt-2">
            <summary style="cursor:pointer;font-size:0.85rem;color:#9ca3af;">Debug: Request variables JSON</summary>
            <textarea id="variablesDebug" readonly>{}</textarea>
          </details>

          <button id="btnEvaluate" class="mt-2">Evaluate DMN</button>
          <span id="evalStatus" class="badge"></span>
          <div id="evalError" class="error"></div>

          <h2 class="mt-3">4. Result</h2>
          <pre id="resultOutput">{}</pre>
        </div>

        <div>
          <h2>Decision table view</h2>
          <div id="decisionTableWrapper">
            <div id="decisionTablePlaceholder" style="padding:0.75rem 0.9rem;font-size:0.85rem;color:#6b7280;">
              Decision table for the selected decision will be rendered here.
            </div>
            <div id="decisionTableContainer" style="display:none;"></div>
          </div>
          <div class="rule-legend">
            <span class="demo"></span>
            <span>Rules highlighted in green are matched.</span>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
  let dmnXml = null;
  let decisionsMeta = [];

  const fileInput = document.getElementById("dmnFile");
  const btnParse = document.getElementById("btnParse");
  const parseStatus = document.getElementById("parseStatus");
  const parseError = document.getElementById("parseError");

  const decisionSelect = document.getElementById("decisionSelect");
  const inputsContainer = document.getElementById("inputsContainer");
  const variablesDebug = document.getElementById("variablesDebug");
  const btnEvaluate = document.getElementById("btnEvaluate");
  const evalStatus = document.getElementById("evalStatus");
  const evalError = document.getElementById("evalError");
  const resultOutput = document.getElementById("resultOutput");

  const decisionTableContainer = document.getElementById("decisionTableContainer");
  const decisionTablePlaceholder = document.getElementById("decisionTablePlaceholder");

  function setBadge(el, text) {
    el.textContent = text || "";
  }
  function clearErrors() {
    parseError.textContent = "";
    evalError.textContent = "";
  }

  // --- DMN parsing in browser ------------------------------------------------

  function parseDmn(xml) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(xml, "application/xml");
    const parseErr = doc.querySelector("parsererror");
    if (parseErr) {
      throw new Error("XML parse error");
    }

    const decisions = Array.from(doc.getElementsByTagNameNS("*", "decision"));
    const res = decisions.map(decEl => {
      const id = decEl.getAttribute("id");
      const name = decEl.getAttribute("name") || id;
      const table = firstChildElementByLocalName(decEl, "decisionTable");
      const hitPolicy = table ? (table.getAttribute("hitPolicy") || "UNIQUE") : "UNIQUE";
      return {
        id,
        name,
        hitPolicy,
        inputs: extractInputs(table),
        outputs: extractOutputs(table),
        rules: extractRules(table)
      };
    });
    return res;
  }

  function firstChildElementByLocalName(parent, localName) {
    if (!parent) return null;
    for (const node of parent.childNodes) {
      if (node.nodeType === 1 && node.localName === localName) {
        return node;
      }
    }
    return null;
  }

  function extractInputs(decisionTableEl) {
    if (!decisionTableEl) return [];
    const inputNodes = Array.from(decisionTableEl.getElementsByTagNameNS("*", "input"));
    return inputNodes.map(inputEl => {
      const def = {
        id: inputEl.getAttribute("id"),
        name: null,
        label: inputEl.getAttribute("label") || null,
        typeRef: null,
        allowedValues: []
      };
      const inputExpr = firstChildElementByLocalName(inputEl, "inputExpression");
      if (inputExpr) {
        const typeRef = inputExpr.getAttribute("typeRef");
        if (typeRef) def.typeRef = typeRef;
        const textEl = firstChildElementByLocalName(inputExpr, "text");
        if (textEl && textEl.textContent) {
          def.name = textEl.textContent.trim();
        }
      }
      if (!def.label) def.label = def.name || def.id;

      const inputValues = firstChildElementByLocalName(inputEl, "inputValues");
      if (inputValues) {
        const textEl = firstChildElementByLocalName(inputValues, "text");
        if (textEl && textEl.textContent) {
          def.allowedValues = parseAllowedValues(textEl.textContent.trim());
        }
      }
      return def;
    });
  }

  function extractOutputs(decisionTableEl) {
    if (!decisionTableEl) return [];
    const outputNodes = Array.from(decisionTableEl.getElementsByTagNameNS("*", "output"));
    return outputNodes.map(outputEl => {
      const def = {
        id: outputEl.getAttribute("id"),
        name: outputEl.getAttribute("name"),
        label: outputEl.getAttribute("label"),
        typeRef: outputEl.getAttribute("typeRef")
      };
      if (!def.label) def.label = def.name || def.id;
      return def;
    });
  }

  function extractRules(decisionTableEl) {
    if (!decisionTableEl) return [];
    const ruleNodes = Array.from(decisionTableEl.getElementsByTagNameNS("*", "rule"));
    return ruleNodes.map((ruleEl, idx) => {
      const rule = {
        id: ruleEl.getAttribute("id"),
        index: idx + 1,
        inputEntries: [],
        outputEntries: []
      };
      const inEntries = Array.from(ruleEl.getElementsByTagNameNS("*", "inputEntry"));
      inEntries.forEach(inEl => {
        const t = firstChildElementByLocalName(inEl, "text");
        rule.inputEntries.push(t && t.textContent ? t.textContent.trim() : "");
      });
      const outEntries = Array.from(ruleEl.getElementsByTagNameNS("*", "outputEntry"));
      outEntries.forEach(outEl => {
        const t = firstChildElementByLocalName(outEl, "text");
        rule.outputEntries.push(t && t.textContent ? t.textContent.trim() : "");
      });
      return rule;
    });
  }

  function parseAllowedValues(raw) {
    const values = [];
    if (!raw) return values;
    if (raw.includes("..") || raw.includes(">") || raw.includes("<")) return values;

    let trimmed = raw.trim();
    if (trimmed.startsWith("[") && trimmed.endsWith("]")) {
      trimmed = trimmed.slice(1, -1);
    }
    const parts = trimmed.split(",");
    for (let p of parts) {
      let v = p.trim();
      if (v.startsWith('"') && v.endsWith('"') && v.length >= 2) {
        v = v.slice(1, -1);
      }
      if (v) values.push(v);
    }
    return values;
  }

  // --- UI rendering ----------------------------------------------------------

  function feelTypeToInputType(typeRef) {
    if (!typeRef) return "text";
    const t = typeRef.toLowerCase();
    if (t.endsWith("boolean")) return "boolean";
    if (t.endsWith("integer") || t.endsWith("number") || t.endsWith("double") || t.endsWith("long")) return "number";
    return "text";
  }

  function renderInputsForDecision(decision) {
    inputsContainer.innerHTML = "";
    if (!decision || !decision.inputs || !decision.inputs.length) {
      const p = document.createElement("p");
      p.style.fontSize = "0.85rem";
      p.style.color = "#6b7280";
      p.textContent = "No inputs found for this decision. You can still evaluate.";
      inputsContainer.appendChild(p);
      variablesDebug.value = "{}";
      return;
    }

    for (const input of decision.inputs) {
      const field = document.createElement("div");
      field.className = "input-field";

      const row = document.createElement("div");
      row.className = "input-label-row";

      const label = document.createElement("label");
      const labelText = input.label || input.name || input.id || "(input)";
      label.textContent = labelText;
      label.htmlFor = "in_" + (input.id || input.name || Math.random().toString(36).slice(2));

      const typeBadge = document.createElement("span");
      typeBadge.className = "type";
      typeBadge.textContent = input.typeRef || "string";

      row.appendChild(label);
      row.appendChild(typeBadge);
      field.appendChild(row);

      const fieldId = label.htmlFor;
      const kind = feelTypeToInputType(input.typeRef);
      let control;

      if (Array.isArray(input.allowedValues) && input.allowedValues.length > 0) {
        control = document.createElement("select");
        const emptyOpt = document.createElement("option");
        emptyOpt.value = "";
        emptyOpt.textContent = "-- select --";
        control.appendChild(emptyOpt);
        for (const v of input.allowedValues) {
          const opt = document.createElement("option");
          opt.value = v;
          opt.textContent = v;
          control.appendChild(opt);
        }
      } else if (kind === "boolean") {
        control = document.createElement("input");
        control.type = "checkbox";
        control.style.width = "auto";
      } else if (kind === "number") {
        control = document.createElement("input");
        control.type = "number";
      } else {
        control = document.createElement("input");
        control.type = "text";
      }

      control.id = fieldId;
      control.dataset.inputName = input.name || input.label || input.id;
      control.dataset.inputKind = kind;

      field.appendChild(control);

      if (Array.isArray(input.allowedValues) && input.allowedValues.length > 0) {
        const hint = document.createElement("div");
        hint.className = "input-hint";
        hint.textContent = "Allowed values: " + input.allowedValues.join(", ");
        field.appendChild(hint);
      }

      inputsContainer.appendChild(field);
    }

    updateVariablesDebug();
  }

  function renderDecisionTable(decision) {
    if (!decision) {
      decisionTableContainer.style.display = "none";
      decisionTablePlaceholder.style.display = "block";
      decisionTablePlaceholder.textContent = "Decision not found.";
      return;
    }

    const inputs = decision.inputs || [];
    const outputs = decision.outputs || [];
    const rules = decision.rules || [];

    if (!rules.length) {
      decisionTableContainer.style.display = "none";
      decisionTablePlaceholder.style.display = "block";
      decisionTablePlaceholder.textContent = "No decision table rules found.";
      return;
    }

    const table = document.createElement("table");
    table.className = "decision-table";

    const thead = document.createElement("thead");
    const headerRow = document.createElement("tr");

    const thIndex = document.createElement("th");
    thIndex.textContent = "#";
    headerRow.appendChild(thIndex);

    inputs.forEach((inp, idx) => {
      const th = document.createElement("th");
      const label = inp.label || inp.name || inp.id || ("Input " + (idx + 1));
      th.innerHTML = label + (inp.typeRef ? "<small>" + inp.typeRef + "</small>" : "");
      headerRow.appendChild(th);
    });

    outputs.forEach((out, idx) => {
      const th = document.createElement("th");
      const label = out.label || out.name || out.id || ("Output " + (idx + 1));
      th.innerHTML = label + (out.typeRef ? "<small>" + out.typeRef + "</small>" : "");
      headerRow.appendChild(th);
    });

    thead.appendChild(headerRow);
    table.appendChild(thead);

    const tbody = document.createElement("tbody");
    rules.forEach(rule => {
      const tr = document.createElement("tr");
      tr.dataset.ruleIndex = String(rule.index);

      const tdIndex = document.createElement("td");
      tdIndex.className = "rule-index-cell";
      tdIndex.textContent = rule.index;
      tr.appendChild(tdIndex);

      inputs.forEach((_, idx) => {
        const td = document.createElement("td");
        td.textContent = (rule.inputEntries && rule.inputEntries[idx]) || "";
        tr.appendChild(td);
      });

      outputs.forEach((_, idx) => {
        const td = document.createElement("td");
        td.textContent = (rule.outputEntries && rule.outputEntries[idx]) || "";
        tr.appendChild(td);
      });

      tbody.appendChild(tr);
    });

    table.appendChild(tbody);
    decisionTableContainer.innerHTML = "";
    decisionTableContainer.appendChild(table);
    decisionTableContainer.style.display = "block";
    decisionTablePlaceholder.style.display = "none";
  }

  function highlightMatchedRules(matchedIndexes) {
    const rows = decisionTableContainer.querySelectorAll("tr[data-rule-index]");
    const set = new Set((matchedIndexes || []).map(x => Number(x)));
    rows.forEach(row => {
      const idx = Number(row.dataset.ruleIndex);
      if (set.has(idx)) {
        row.classList.add("rule-hit");
      } else {
        row.classList.remove("rule-hit");
      }
    });
  }

  function collectVariablesFromForm() {
    const vars = {};
    const controls = inputsContainer.querySelectorAll("input, select");
    controls.forEach(ctrl => {
      const name = ctrl.dataset.inputName;
      const kind = ctrl.dataset.inputKind || "text";
      if (!name) return;

      if (ctrl.tagName === "SELECT") {
        if (ctrl.value !== "") vars[name] = ctrl.value;
      } else if (kind === "boolean") {
        vars[name] = ctrl.checked;
      } else if (kind === "number") {
        const val = ctrl.value.trim();
        if (val !== "") {
          const n = Number(val);
          if (!Number.isNaN(n)) vars[name] = n;
        }
      } else {
        const val = ctrl.value.trim();
        if (val !== "") vars[name] = val;
      }
    });
    return vars;
  }

  function updateVariablesDebug() {
    const vars = collectVariablesFromForm();
    variablesDebug.value = JSON.stringify(vars, null, 2);
  }

  inputsContainer.addEventListener("input", updateVariablesDebug);

  // --- DMN evaluation in browser --------------------------------------------

  function evalDecision(decision, variables) {
    const results = [];
    const matchedRuleIndexes = [];

    for (const rule of decision.rules) {
      let allInputsMatch = true;
      for (let i = 0; i < decision.inputs.length; i++) {
        const inputDef = decision.inputs[i];
        const cellText = rule.inputEntries[i] || "";
        const varName = inputDef.name || inputDef.label || inputDef.id;
        const value = variables[varName];

        if (!evalUnaryTest(cellText, value)) {
          allInputsMatch = false;
          break;
        }
      }
      if (allInputsMatch) {
        matchedRuleIndexes.push(rule.index);
        const outObj = {};
        for (let j = 0; j < decision.outputs.length; j++) {
          const outDef = decision.outputs[j];
          const outText = rule.outputEntries[j] || "";
          outObj[outDef.name || outDef.label || outDef.id] = evalLiteral(outText, variables);
        }
        results.push(outObj);
        if (decision.hitPolicy && decision.hitPolicy.toUpperCase() === "FIRST") {
          break;
        }
      }
    }

    let finalResult;
    if (decision.hitPolicy && decision.hitPolicy.toUpperCase() === "FIRST") {
      finalResult = results.length ? results[0] : null;
    } else {
      finalResult = results;
    }

    return { result: finalResult, matchedRuleIndexes };
  }

  function evalUnaryTest(text, value) {
    if (text == null) return true;
    const t = text.trim();
    if (t === "" || t === "-") return true;

    // multiple tests separated by comma â†’ OR
    const parts = splitTopLevel(t, ",");
    return parts.some(p => evalSingleUnaryTest(p.trim(), value));
  }

  function evalSingleUnaryTest(expr, value) {
    if (expr === "") return true;

    // strip outer parentheses
    while (expr.startsWith("(") && expr.endsWith(")")) {
      expr = expr.slice(1, -1).trim();
    }
    if (expr === "") return true;

    // string literal "foo"
    if (expr.startsWith('"') && expr.endsWith('"') && expr.length >= 2) {
      const lit = expr.slice(1, -1);
      return String(value) === lit;
    }

    // boolean literal
    if (expr === "true" || expr === "false") {
      const lit = (expr === "true");
      return String(value) === String(lit);
    }

    // interval: [a..b], (a..b], [a..b), (a..b)
    const intervalMatch = expr.match(/^(\[|\()([^\.]+)\.\.([^ \]\)]+)(\]|\))$/);
    if (intervalMatch) {
      const lowerInc = intervalMatch[1] === "[";
      const upperInc = intervalMatch[4] === "]";
      const lower = Number(intervalMatch[2].trim());
      const upper = Number(intervalMatch[3].trim());
      const v = Number(value);
      if (Number.isNaN(v) || Number.isNaN(lower) || Number.isNaN(upper)) return false;
      if (lowerInc ? v < lower : v <= lower) return false;
      if (upperInc ? v > upper : v >= upper) return false;
      return true;
    }

    // comparisons: < 5, > 3, <= 10, >= 7
    const compMatch = expr.match(/^(<=|>=|<|>)(.+)$/);
    if (compMatch) {
      const op = compMatch[1];
      const rhs = Number(compMatch[2].trim());
      const v = Number(value);
      if (Number.isNaN(v) || Number.isNaN(rhs)) return false;
      switch (op) {
        case "<":  return v < rhs;
        case "<=": return v <= rhs;
        case ">":  return v > rhs;
        case ">=": return v >= rhs;
      }
    }

    // numeric literal
    const num = Number(expr);
    if (!Number.isNaN(num)) {
      return Number(value) === num;
    }

    // fallback: string equality
    return String(value) === expr;
  }

  function splitTopLevel(str, sep) {
    const result = [];
    let current = "";
    let inString = false;
    let bracketDepth = 0;
    for (let i = 0; i < str.length; i++) {
      const ch = str[i];
      if (ch === '"') {
        inString = !inString;
        current += ch;
      } else if (!inString && (ch === "[" || ch === "(")) {
        bracketDepth++;
        current += ch;
      } else if (!inString && (ch === "]" || ch === ")")) {
        bracketDepth--;
        current += ch;
      } else if (!inString && bracketDepth === 0 && str.startsWith(sep, i)) {
        result.push(current);
        current = "";
        i += sep.length - 1;
      } else {
        current += ch;
      }
    }
    if (current) result.push(current);
    return result;
  }

  function evalLiteral(text, vars) {
    if (text == null) return null;
    const t = text.trim();
    if (t === "") return null;

    if (t.startsWith('"') && t.endsWith('"') && t.length >= 2) {
      return t.slice(1, -1);
    }
    if (t === "true") return true;
    if (t === "false") return false;
    const n = Number(t);
    if (!Number.isNaN(n)) return n;
    // fallback: raw text
    return t;
  }

  // --- Events ----------------------------------------------------------------

  btnParse.addEventListener("click", () => {
    clearErrors();
    setBadge(parseStatus, "");
    decisionsMeta = [];
    dmnXml = null;
    decisionSelect.innerHTML = '<option value="">-- parsing... --</option>';
    inputsContainer.innerHTML = '<p style="font-size:0.85rem;color:#6b7280;">Inputs will appear here after selecting a decision.</p>';
    variablesDebug.value = "{}";
    decisionTableContainer.innerHTML = "";
    decisionTableContainer.style.display = "none";
    decisionTablePlaceholder.style.display = "block";
    decisionTablePlaceholder.textContent = "Decision table for the selected decision will be rendered here.";
    highlightMatchedRules([]);

    const file = fileInput.files[0];
    if (!file) {
      parseError.textContent = "Please pick a DMN file first.";
      decisionSelect.innerHTML = '<option value="">-- no DMN loaded --</option>';
      return;
    }

    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        dmnXml = e.target.result;
        decisionsMeta = parseDmn(dmnXml);
        if (!decisionsMeta.length) {
          decisionSelect.innerHTML = '<option value="">-- no decisions found --</option>';
          setBadge(parseStatus, "0 decisions");
        } else {
          decisionSelect.innerHTML = "";
          for (const d of decisionsMeta) {
            const opt = document.createElement("option");
            opt.value = d.id;
            opt.textContent = `${d.name || d.id} (${d.id})`;
            decisionSelect.appendChild(opt);
          }
          setBadge(parseStatus, `Loaded ${decisionsMeta.length} decision(s)`);
          const firstId = decisionsMeta[0].id;
          decisionSelect.value = firstId;
          const decision = decisionsMeta.find(x => x.id === firstId);
          renderInputsForDecision(decision);
          renderDecisionTable(decision);
        }
      } catch (err) {
        console.error(err);
        parseError.textContent = "Failed to parse DMN: " + err.message;
        decisionSelect.innerHTML = '<option value="">-- error loading DMN --</option>';
      }
    };
    reader.onerror = () => {
      parseError.textContent = "Failed to read DMN file.";
    };
    reader.readAsText(file);
  });

  decisionSelect.addEventListener("change", () => {
    const id = decisionSelect.value;
    const decision = decisionsMeta.find(d => d.id === id);
    renderInputsForDecision(decision);
    renderDecisionTable(decision);
    highlightMatchedRules([]);
  });

  btnEvaluate.addEventListener("click", () => {
    clearErrors();
    setBadge(evalStatus, "");
    resultOutput.textContent = "{}";
    highlightMatchedRules([]);

    if (!dmnXml) {
      evalError.textContent = "Please upload & parse a DMN file first.";
      return;
    }
    const decisionId = decisionSelect.value;
    if (!decisionId) {
      evalError.textContent = "Please select a decision.";
      return;
    }
    const decision = decisionsMeta.find(d => d.id === decisionId);
    if (!decision) {
      evalError.textContent = "Invalid decision.";
      return;
    }

    const vars = collectVariablesFromForm();
    variablesDebug.value = JSON.stringify(vars, null, 2);

    try {
      setBadge(evalStatus, "Evaluating...");
      const { result, matchedRuleIndexes } = evalDecision(decision, vars);
      resultOutput.textContent = JSON.stringify(result, null, 2);
      highlightMatchedRules(matchedRuleIndexes);
      setBadge(evalStatus, "Done");
    } catch (err) {
      console.error(err);
      evalError.textContent = "Evaluation failed: " + err.message;
      setBadge(evalStatus, "Error");
    }
  });
</script>
</body>
</html>
